# migrate_ms_sql_to_mysql_5_tables.py
import pandas as pd
from sqlalchemy import create_engine, text
import urllib

# ---------- ENGINES ----------
MSSQL_SERVER   = "DESKTOP-6B6KT5K"
MSSQL_DB       = "cryptodb"
MSSQL_DRIVER   = "ODBC Driver 17 for SQL Server"

mssql_conn_str = (
    f"Driver={{{MSSQL_DRIVER}}};"
    f"Server={MSSQL_SERVER};"
    f"Database={MSSQL_DB};"
    "Trusted_Connection=yes;"
)
mssql_engine = create_engine(
    f"mssql+pyodbc:///?odbc_connect={urllib.parse.quote_plus(mssql_conn_str)}",
    fast_executemany=True
)

# NOTE: password has '@' â†’ encoded as %40
mysql_engine = create_engine("mysql+pymysql://root:thinknyx%40123@localhost/CompanyDB")

# ---------- TABLES TO MIGRATE ----------
# Source MS SQL -> Target MySQL tables (same name)
TABLES = [
    "crypto_data",
    "customers_big",
    "orders_big",
    "pageviews_big",
    "products_big",
]

CHUNKSIZE_READ  = 100_000  # pull in sizeable chunks from MSSQL
TO_SQL_CHUNKS   = 50_000   # write batch size into MySQL

def transform_crypto_data(df: pd.DataFrame) -> pd.DataFrame:
    """Apply IQR-based price category + dominance only for crypto_data."""
    if "current_price" in df.columns and not df["current_price"].empty:
        q1 = df["current_price"].quantile(0.25)
        q3 = df["current_price"].quantile(0.75)
        iqr = q3 - q1
        lower = q1 - 1.5 * iqr
        upper = q3 + 1.5 * iqr

        def cat(p):
            if pd.isna(p):
                return "Unknown"
            if p < lower: return "Low"
            if p > upper: return "High"
            return "Medium"

        df["price_category"] = df["current_price"].apply(cat)

    if "market_cap" in df.columns:
        total_mc = df["market_cap"].sum()
        if total_mc and total_mc != 0:
            df["market_dominance_pct"] = (df["market_cap"] / total_mc * 100).round(2)
        else:
            df["market_dominance_pct"] = 0.0
    return df

def identity(df: pd.DataFrame) -> pd.DataFrame:
    return df

TRANSFORMS = {
    "crypto_data": transform_crypto_data,
    "customers_big": identity,
    "orders_big": identity,
    "pageviews_big": identity,
    "products_big": identity,
}

def migrate_one_table(table_name: str):
    print(f"[migrate] Starting {table_name} ...")
    first_chunk = True
    query = f"SELECT * FROM {table_name}"
    total = 0

    for chunk in pd.read_sql(query, mssql_engine, chunksize=CHUNKSIZE_READ):
        # transform per-table
        fn = TRANSFORMS.get(table_name, identity)
        chunk = fn(chunk)

        # write to MySQL
        chunk.to_sql(table_name, mysql_engine,
                     if_exists="replace" if first_chunk else "append",
                     index=False, chunksize=TO_SQL_CHUNKS)
        total += len(chunk)
        first_chunk = False
        print(f"[migrate] {table_name}: migrated {len(chunk)} rows (total {total})")

    # verify
    with mysql_engine.connect() as conn:
        cnt = conn.execute(text(f"SELECT COUNT(*) FROM {table_name}")).scalar()
        print(f"[migrate] {table_name}: MySQL row count = {cnt}")

def main():
    for t in TABLES:
        migrate_one_table(t)

if __name__ == "__main__":
    main()
